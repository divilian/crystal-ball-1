
\chapter[Tables in Python (2 of 3)]{\huge\selectfont{Tables in Python (2 of
3)}}

\label{tablesInPython2}
\index{row (of a \texttt{DataFrame})}
\index{row (of a table)}
\index{column (of a table)}

It's easy to get tripped up on Pandas' syntax for accessing the individual bits
of \texttt{DataFrame}s. First, let's talk about rows and columns, and then
we'll talk about the atomic elements (``cells'') themselves.

\section{Accessing individual rows and columns}

\label{accessIndividualRowsColsOfDataFrame}

Suppose you have a \texttt{DataFrame} called \texttt{df}. Here's how you can
extract particular rows and columns:

\begin{compactitem}
\item \texttt{df.loc[}\textsl{i}\texttt{]} -- access the \textbf{row} with
\textbf{index} \textsl{i}
\item \texttt{df.iloc[}\textsl{n}\texttt{]} -- access \textbf{row} number
\textsl{n}
\item \texttt{df[}\textsl{c}\texttt{]} -- access \textbf{column} \textsl{c}
\end{compactitem}

\index{iloc@\texttt{.iloc} syntax (Pandas)}
\index{loc@\texttt{.loc} syntax (Pandas)}

The second of these is reminiscent of the \texttt{.iloc} syntax we learned for
\texttt{Series}es on p.~\pageref{iloc}. With it, we specify the \textit{number}
we want, rather than the index/key/label. That's not super common to do, but it
happens. More common is the first form: we specify the row we want by its
index.

The last one is tricky, because everyone (including me, several times a week,
it seems) assumes that just typing (say) ``\texttt{df['Bart']}'' would give you
\texttt{Bart}'s row. This is probably how it \textit{ought} to work, since
\texttt{Series}es worked that way. Alas, no: if you specify neither
\texttt{.loc} nor \texttt{.iloc}, you're asking for a \textit{column}, not a
row.

% WARNING: "bottom of" might not be correct if we change ch.16 text.

Yet another odd thing is how a single row is presented on the screen. Let's go
back to the \texttt{simpsons} data set (bottom of p.~\pageref{finalSimpsons}),
and access the \texttt{Bart} row the proper way (with \texttt{.loc}):

\begin{Verbatim}[fontsize=\small,samepage=true,frame=single,framesep=3mm]
print(simpsons.loc['Bart'])
\end{Verbatim}
\vspace{-.2in}

\begin{Verbatim}[fontsize=\small,samepage=true,frame=leftline,framesep=5mm,framerule=1mm]
species         human
age                10
gender              M
fave       skateboard
IQ                 90
hair             buzz
salary              0
Name: Bart, dtype: object
\end{Verbatim}

This bugs the heck out of me. Bart, like all other Simpsons, was a \textit{row}
in the original \texttt{DataFrame}, but here, it presents Bart's information
vertically instead of horizontally. I find it visually jarring. The reason
Pandas does it this way is that \textit{each row of a \texttt{DataFrame} is a
\texttt{Series}}, and the way Pandas displays \texttt{Series}es is vertically.
We'll deal somehow.

\index{double boxies@``double boxies''}

Btw, for any of the three options, you can provide a \textit{list} with
multiple things you want, instead of just one thing. You do so by using
\textit{double} boxies:

\begin{compactitem}
\item \texttt{df.loc[[}\textsl{i1,i2,i3,\dots}\texttt{]]} -- access the
row\textbf{s} with indices \textsl{i1, i2, i3,} \textit{etc.}
\item \texttt{df.iloc[[}\textsl{n1,n2,n3,\dots}\texttt{]]} -- access the row\textbf{s}
numbered \textsl{n1, n2, n3,} \textit{etc.}
\item \texttt{df[[}\textsl{c1,c2,c3,\dots}\texttt{]]} -- access the
column\textbf{s} names \textsl{c1, c2, c3,} \textit{etc.}
\end{compactitem}

\subsection{Examples}

To test your understanding of all of the above, confirm that you understand the
following examples:

\begin{Verbatim}[fontsize=\scriptsize,samepage=true,frame=single,framesep=3mm]
print(simpsons.iloc[3])
\end{Verbatim}
\vspace{-.2in}

\begin{Verbatim}[fontsize=\scriptsize,samepage=true,frame=leftline,framesep=5mm,framerule=1mm]
species        human
age                8
gender             F
fave       saxophone
IQ               200
hair           curly
salary             0
Name: Lisa, dtype: object
\end{Verbatim}

\medskip

\begin{Verbatim}[fontsize=\scriptsize,samepage=true,frame=single,framesep=3mm]
print(simpsons['age'])
\end{Verbatim}
\vspace{-.2in}

\begin{Verbatim}[fontsize=\scriptsize,samepage=true,frame=leftline,framesep=5mm,framerule=1mm]
name
Homer     36
Marge     34
Bart      10
Lisa       8
Maggie     1
SLH        4
Name: age, dtype: int64
\end{Verbatim}

\medskip
\begin{Verbatim}[fontsize=\scriptsize,samepage=true,frame=single,framesep=3mm]
print(simpsons.loc[['Lisa','Maggie','Bart']])
\end{Verbatim}
\vspace{-.2in}

\begin{Verbatim}[fontsize=\scriptsize,samepage=true,frame=leftline,framesep=5mm,framerule=1mm]
       species  age gender        fave     IQ   hair  salary
name                                                        
Lisa     human    8      F   saxophone  200.0  curly     0.0
Maggie   human    1      F    pacifier  100.0  curly     0.0
Bart     human   10      M  skateboard   90.0   buzz     0.0
\end{Verbatim}

\medskip
\begin{Verbatim}[fontsize=\scriptsize,samepage=true,frame=single,framesep=3mm]
print(simpsons.iloc[[1,3,4]])
\end{Verbatim}
\vspace{-.2in}

\begin{Verbatim}[fontsize=\scriptsize,samepage=true,frame=leftline,framesep=5mm,framerule=1mm]
       species  age gender            fave     IQ          hair  salary
name                                                                   
Marge    human   34      F  helping others  120.0  stacked tall     0.0
Lisa     human    8      F       saxophone  200.0         curly     0.0
Maggie   human    1      F        pacifier  100.0         curly     0.0
\end{Verbatim}

\medskip
\begin{Verbatim}[fontsize=\scriptsize,samepage=true,frame=single,framesep=3mm]
print(simpsons[['age','fave','IQ']])
\end{Verbatim}
\vspace{-.2in}

\begin{Verbatim}[fontsize=\scriptsize,samepage=true,frame=leftline,framesep=5mm,framerule=1mm]
        age            fave     IQ
name                              
Homer    36            beer   74.0
Marge    34  helping others  120.0
Bart     10      skateboard   90.0
Lisa      8       saxophone  200.0
Maggie    1        pacifier  100.0
SLH       4             NaN   30.0
\end{Verbatim}

Incidentally, you'll notice how the \texttt{name} values are treated
differently from all the other columns, since \texttt{name} is the
\texttt{DataFrame}'s index. For one thing, \texttt{name} \textit{always}
appears, even though it's not included among the columns we asked for. For
another, it's listed at the bottom of the single-row \texttt{Series} listings
rather than up with the other values in that row.

\section{Accessing individual elements}

\label{accessIndividualElementsOfDataFrame}

I mentioned above the eternal truth that \textit{each row of a
\texttt{DataFrame} is a \texttt{Series}}. Once you grasp this, you'll realize
that you can access an individual ``cell'' of a \texttt{DataFrame} simply by
getting the row you want, and then getting the specific value from that. A
two-step process for doing this would be:

\begin{Verbatim}[fontsize=\small,samepage=true,frame=single,framesep=3mm]
lisas_row = simpsons.loc['Lisa']
lisas_iq = lisas_row['IQ']
print(lisas_iq)
\end{Verbatim}
\vspace{-.2in}

\begin{Verbatim}[fontsize=\small,samepage=true,frame=leftline,framesep=5mm,framerule=1mm]
200.0
\end{Verbatim}

But a shorter, one-stepper just combines these two operations on the same line:

\begin{Verbatim}[fontsize=\small,samepage=true,frame=single,framesep=3mm]
lisas_iq = simpsons.loc['Lisa']['IQ']
print(lisas_iq)
\end{Verbatim}
\vspace{-.2in}

\begin{Verbatim}[fontsize=\small,samepage=true,frame=leftline,framesep=5mm,framerule=1mm]
200.0
\end{Verbatim}

\section{Accessing a \texttt{DataFrame}'s metadata}

\index{metadata}
\index{index@\texttt{.index} syntax (Pandas)}

We can get some meta-information about a \texttt{DataFrame} without even
looking at individual rows. If we want to know what the index values themselves
are, we use \texttt{.index}:

\begin{Verbatim}[fontsize=\small,samepage=true,frame=single,framesep=3mm]
print(simpsons.index)
\end{Verbatim}
\vspace{-.2in}

\begin{Verbatim}[fontsize=\small,samepage=true,frame=leftline,framesep=5mm,framerule=1mm]
Index(['Homer', 'Marge', 'Bart', 'Lisa', 'Maggie', 'SLH'],
    dtype='object', name='name')
\end{Verbatim}

That weird-looking output tells us several things. First, the index of this
\texttt{DataFrame} consists of \texttt{string}s (recall that's what
``\texttt{dtype='object'}'' means; see p.~\pageref{dtypeRules}.) Second, the
\textit{name} of the index column is, ironically, ``\texttt{name}''. (It could
be named anything at all, of course.) Third, the actual index values are
\texttt{Homer}, \texttt{Marge}, and all the rest.

\index{columns@\texttt{.columns} (Pandas)}

That's the index, or the ``row names,'' if you will. To get the column names,
we use \texttt{.columns}:

\begin{Verbatim}[fontsize=\small,samepage=true,frame=single,framesep=3mm]
print(simpsons.columns)
\end{Verbatim}
\vspace{-.2in}

\begin{Verbatim}[fontsize=\small,samepage=true,frame=leftline,framesep=5mm,framerule=1mm]
Index(['species', 'age', 'gender', 'fave', 'IQ', 'hair', 'salary'],
    dtype='object')
\end{Verbatim}

Interestingly, this too is an ``\texttt{Index}'' beast, also comprised of
\texttt{string}s. Pandas treats both ``axes'' of a \texttt{DataFrame}
similarly, in that both of them are the same type of thing (an
``\texttt{Index}''). Notice that \texttt{name} is not present in the column
names list, because as the \texttt{DataFrame}'s index it's a different sort of
thing.

\index{len@\texttt{len()}}

How many rows does a \texttt{DataFrame} have? This is answerable by using the
\texttt{len()} function again:

\begin{Verbatim}[fontsize=\small,samepage=true,frame=single,framesep=3mm]
print(len(simpsons))
\end{Verbatim}
\vspace{-.2in}

\begin{Verbatim}[fontsize=\small,samepage=true,frame=leftline,framesep=5mm,framerule=1mm]
6
\end{Verbatim}

This is our third use of the word \texttt{len()}: it can be used to find the
number of characters in a \texttt{string}, the number of key/value pairs of a
\texttt{Series}, and (here) the number of rows of a \texttt{DataFrame}.

\index{shape@\texttt{.shape} (Pandas)}
Finally, we often want to get a quick sense of how large a \texttt{DataFrame}
is, both in terms of rows and columns. The \texttt{.shape} syntax is handy
here:

\begin{samepage}
\begin{Verbatim}[fontsize=\small,samepage=true,frame=single,framesep=3mm]
print(simpsons.shape)
\end{Verbatim}
\vspace{-.2in}

\begin{Verbatim}[fontsize=\small,samepage=true,frame=leftline,framesep=5mm,framerule=1mm]
(6, 7)
\end{Verbatim}
\end{samepage}

This tells us that \texttt{simpsons} has six rows and seven columns. As I
mentioned previously (p.~\pageref{tallAndSkinny}) this is definitely not the
typical case: most \texttt{DataFrames} will have many more rows (thousands or
even millions) than columns (at most, dozens).

\section{Sorting \texttt{DataFrame}s}
\index{sorting@sorting (\texttt{DataFrame}s)}

Sorting a \texttt{DataFrame} is largely like sorting a \texttt{Series}, except
we have more choices: instead of just the keys and the values, we have the
index and potentially \textit{many} different columns.

\index{sort\_index@\texttt{.sort\_index()} method (Pandas)}
The \texttt{.sort\_index()} method works just like it did for
\texttt{Series}es:

\begin{samepage}
\begin{Verbatim}[fontsize=\small,samepage=true,frame=single,framesep=3mm]
print(simpsons.sort_index())
\end{Verbatim}
\vspace{-.2in}

\begin{Verbatim}[fontsize=\small,samepage=true,frame=leftline,framesep=5mm,framerule=1mm]
       species  age gender            fave     IQ          hair   salary
name                                                                    
Bart     human   10      M      skateboard   90.0          buzz      0.0
Homer    human   36      M            beer   74.0          none  52000.0
Lisa     human    8      F       saxophone  200.0         curly      0.0
Maggie   human    1      F        pacifier  100.0         curly      0.0
Marge    human   34      F  helping others  120.0  stacked tall      0.0
SLH        dog    4      M             NaN   30.0        shaggy      0.0
\end{Verbatim}
\end{samepage}

The result is rows sorted alphabetically by name. And I hate to keep repeating
myself, but remember that \texttt{.sort\_index()} returns a modified copy,
unless you pass the \texttt{inplace=True} argument. The
\texttt{ascending=False} argument is also allowed, and will sort by the index
highest-to-lowest instead of lowest-to-highest.

\index{sort\_values@\texttt{.sort\_values()} method (Pandas)}
To sort by one of the columns, we call \texttt{.sort\_values()} and pass it the
column name:

\begin{Verbatim}[fontsize=\small,samepage=true,frame=single,framesep=3mm]
print(simpsons.sort_index('IQ')
\end{Verbatim}
\vspace{-.2in}

\begin{Verbatim}[fontsize=\small,samepage=true,frame=leftline,framesep=5mm,framerule=1mm]
       species  age gender            fave     IQ          hair   salary
name                                                                    
SLH        dog    4      M             NaN   30.0        shaggy      0.0
Homer    human   36      M            beer   74.0          none  52000.0
Bart     human   10      M      skateboard   90.0          buzz      0.0
Maggie   human    1      F        pacifier  100.0         curly      0.0
Marge    human   34      F  helping others  120.0  stacked tall      0.0
Lisa     human    8      F       saxophone  200.0         curly      0.0
\end{Verbatim}

\index{tie-breaker}

Sometimes we want to include more than one column in the sort. Why? As a
tie-breaker. Consider sorting a roster for a student club, which has
\texttt{first\_name} and \texttt{last\_name} columns, among other things. We
might want to sort the list alphabetically by last name, but for students with
the same last name, we should go to the first name as a tie-breaker (so that
\texttt{Angela Smith} shows up after \texttt{Velma Patterson} but before
\texttt{Brad Smith}).

To do this, we pass a list of columns, instead of a single column:

\begin{samepage}
\begin{Verbatim}[fontsize=\small,samepage=true,frame=single,framesep=3mm]
print(simpsons.sort_values(['gender','hair','IQ']))
\end{Verbatim}
\vspace{-.2in}

\begin{Verbatim}[fontsize=\small,samepage=true,frame=leftline,framesep=5mm,framerule=1mm]
       species  age gender            fave     IQ          hair   salary
name                                                                    
Maggie   human    1      F        pacifier  100.0         curly      0.0
Lisa     human    8      F       saxophone  200.0         curly      0.0
Marge    human   34      F  helping others  120.0  stacked tall      0.0
Bart     human   10      M      skateboard   90.0          buzz      0.0
Homer    human   36      M            beer   74.0          none  52000.0
SLH        dog    4      M             NaN   30.0        shaggy      0.0
\end{Verbatim}
\end{samepage}

Here, we said ``sort the rows alphabetically by \texttt{gender}. For rows with
the same \texttt{gender}, use \texttt{hair} as a tie-breaker. And for rows with
the same \texttt{gender} \textit{and} the same \texttt{hair}, use \texttt{IQ}
as a second tie-breaker.'' Glance at that output and convince yourself that
it's correct.

We control the ``ascendingness'' of the multi-column sort by specifying a list
of \textit{each} \texttt{ascending} value, one for each column we're sorting
by. Consider this:

\begin{samepage}
\begin{Verbatim}[fontsize=\small,samepage=true,frame=single,framesep=3mm]
print(simpsons.sort_values(['gender','hair','IQ'],
    ascending=[False,True,False]))
\end{Verbatim}
\vspace{-.2in}

\begin{Verbatim}[fontsize=\small,samepage=true,frame=leftline,framesep=5mm,framerule=1mm]
       species  age gender            fave     IQ          hair   salary
name                                                                    
Bart     human   10      M      skateboard   90.0          buzz      0.0
Homer    human   36      M            beer   74.0          none  52000.0
SLH        dog    4      M             NaN   30.0        shaggy      0.0
Lisa     human    8      F       saxophone  200.0         curly      0.0
Maggie   human    1      F        pacifier  100.0         curly      0.0
Marge    human   34      F  helping others  120.0  stacked tall      0.0
\end{Verbatim}
\end{samepage}

Now we're saying ``sort \textit{reverse} alphabetically by \texttt{gender},
breaking ties by comparing \texttt{hair} alphabetically, and breaking further
ties by \texttt{reverse} sorted order by IQ.''

Oh, and the \texttt{inplace=True} argument works for all these examples as
well.

\section{Summary statistics for \texttt{DataFrame}s}

\index{summary statistics}

Summary statistics like the mean, median, minimum/maximum, and the like, can of
course all be computed on individual columns of a \texttt{DataFrame}, because
each column is a \texttt{Series}:

\index{median}

\begin{samepage}
\begin{Verbatim}[fontsize=\small,samepage=true,frame=single,framesep=3mm]
print(simpsons['IQ'].median())
\end{Verbatim}
\vspace{-.2in}

\begin{Verbatim}[fontsize=\small,samepage=true,frame=leftline,framesep=5mm,framerule=1mm]
95.0
\end{Verbatim}
\end{samepage}

\begin{samepage}
\begin{Verbatim}[fontsize=\small,samepage=true,frame=single,framesep=3mm]
print(simpsons['salary'].sum())
\end{Verbatim}
\vspace{-.2in}

\index{sum method@\texttt{.sum()} method (Pandas)}
\begin{Verbatim}[fontsize=\small,samepage=true,frame=leftline,framesep=5mm,framerule=1mm]
52000.0
\end{Verbatim}
\end{samepage}

\index{mean method@\texttt{.mean()} method (Pandas)}
You can also, believe it or not, compute the sum/mean/max/etc on the entire
\texttt{DataFrame}. This computes it on every column individually:

\begin{samepage}
\begin{Verbatim}[fontsize=\small,samepage=true,frame=single,framesep=3mm]
print(simpsons.mean())
\end{Verbatim}
\vspace{-.2in}

\begin{Verbatim}[fontsize=\small,samepage=true,frame=leftline,framesep=5mm,framerule=1mm]
age         15.500000
IQ         102.333333
salary    8666.666667
dtype: float64
\end{Verbatim}
\end{samepage}


Pandas left out the non-numeric columns (\texttt{species}, \texttt{gender},
\textit{etc.}) and computed the mean of each of the others, giving us a
\texttt{Series} containing their values.

\index{describe method@\texttt{.describe()} method (Pandas)}

Finally, I often find the \texttt{.describe()} method useful:

\begin{samepage}
\begin{Verbatim}[fontsize=\small,samepage=true,frame=single,framesep=3mm]
print(simpsons.describe())
\end{Verbatim}
\vspace{-.2in}

\begin{Verbatim}[fontsize=\small,samepage=true,frame=leftline,framesep=5mm,framerule=1mm]
count   6.000000    6.000000      6.000000
mean   15.500000  102.333333   8666.666667
std    15.436969   56.645094  21228.911104
min     1.000000   30.000000      0.000000
25%     5.000000   78.000000      0.000000
50%     9.000000   95.000000      0.000000
75%    28.000000  115.000000      0.000000
max    36.000000  200.000000  52000.000000
\end{Verbatim}
\end{samepage}

\index{quartile}
\index{standard deviation}

Neat! We get the number of values, the mean, the standard deviation, and all
the quartiles for each of the numeric columns. Lots of dashboard information at
a glance!

\section{Recoding and transforming}

\index{US Women's National Team}

It's often the case that although a \texttt{DataFrame} contains the information
you need for your analysis, it's not exactly in the form you need it. Consider
the following soccer data set called \texttt{worldcup2019.csv}:

\begin{Verbatim}[fontsize=\small,samepage=true,frame=lines,framesep=3mm]
last,first,date,in_time,out_time,goals,assists,tackles,fouls
Morgan,Alex,28-Jun-2019,0.0,90.0,0,0,2,1
Rapinoe,Megan,28-Jun-2019,0.0,74.0,2,0,2,2
Press,Christen,28-Jun-2019,74.0,90.0,0,0,1,0
Lavelle,Rose,28-Jun-2019,0.0,90.0,0,1,3,0
Lavelle,Rose,7-Jul-2019,0.0,90.0,1,0,4,1
Rapinoe,Megan,7-Jul-2019,0.0,83.0,1,1,3,2
Lloyd,Carli,7-Jul-2019,87.0,90.0,0,0,1,0
Dunn,Crystal,23-Jun-2019,42.0,81.0,0,1,1,2
\end{Verbatim}

\index{set\_index@\texttt{.set\_index()} method (Pandas)}

Interestingly, if you think about it, this particular \texttt{.csv} file
doesn't really have a meaningful index column. None of the columns are expected
to be unique. So we'll leave off the ``\texttt{.set\_index()}'' method call
when we read it in:

\begin{samepage}
\begin{Verbatim}[fontsize=\scriptsize,samepage=true,frame=single,framesep=3mm]
wc = pd.read_csv('worldcup2019.csv')
print(wc)
\end{Verbatim}
\vspace{-.2in}

\begin{Verbatim}[fontsize=\scriptsize,samepage=true,frame=leftline,framesep=5mm,framerule=1mm]
      last     first    date  in_mins  in_secs  out_mins  out_secs  goals  assists  tackles  fouls
0   Morgan      Alex  28-Jun        0        0        90         0      0        0        2      1
1  Rapinoe     Megan  28-Jun        0        0        74        27      2        0        2      2
2    Press  Christen  28-Jun       74       27        90         0      0        0        1      0
3  Lavelle      Rose  28-Jun        0        0        90         0      0        1        3      0
4  Lavelle      Rose   7-Jul        0        0        90         0      1        0        4      1
5  Rapinoe     Megan   7-Jul        0        0        83        16      1        1        3      2
6    Lloyd     Carli   7-Jul       83       16        90         0      0        0        1      0
7     Dunn   Crystal  23-Jun       42       37        81         5      0        1        1      2
\end{Verbatim}
\end{samepage}

(As you can see, Pandas put in a numeric index column for us.)

Each row of this \texttt{DataFrame} represents one player in one 2019 World Cup
game. Notice we have a couple of players with more than one row (Megan Rapinoe
and Rose Lavelle), and several rows for the same game (the first four rows are
all from the June 28th game, for instance).

Let's zero in on the columns with \texttt{mins} and \texttt{secs} in the names.
These columns show us the minute and second that the player went \texttt{in} to
the game, and the minute and second that they came \texttt{out}. For example,
Alex Morgan played the entire 90-minute match on June 28th. Rapinoe started
that game, but came out for a substitute at the 74:27 mark. Who replaced her?
Looks like Christen Press did, since she \textit{entered} the game at exactly
the same time. In most rows, the player either started the game, or ended the
game or both, but the last row (Crystal Dunn's June 23rd performance) has her
entering at 42:37 and exiting at 81:05.

Now the reason I bring this up is because one aspect of our analysis might be
computing statistics \textit{per minute} that each athlete played. If one
player scored 3 goals in 200 minutes, for example, and another scored 3 goals
in just 150 minutes, we could reasonably say that the second player was a more
prolific scorer in that World Cup.

\index{recoding}

This is hard to do with the data in the form that it stands. So we'll
\textbf{recode} a few of the columns. Let's collapse the minutes and seconds
for each of the two clock times into a single value, in minutes:

% TODO: round to two decimal places
\begin{Verbatim}[fontsize=\small,samepage=true,frame=single,framesep=3mm]
wc['in_time'] = wc['in_mins'] + (wc['in_secs'] / 60)
wc['out_time'] = wc['out_mins'] + (wc['out_secs'] / 60)
\end{Verbatim}

\index{vectorized@``vectorized'' operation}

We're taking advantage of vectorized operations here. For each row, we need to
divide the \texttt{in\_secs} value by 60 (to convert it to minutes) and add it
to the \texttt{in\_mins} value. Pandas makes this super easy here, since we can
just write out those operations once, and it will compute it for every single
row!

Let's delete the old, superfluous columns now and see what we've got:

\begin{samepage}
\begin{Verbatim}[fontsize=\small,samepage=true,frame=single,framesep=3mm]
del wc['in_mins']
del wc['in_secs']
del wc['out_mins']
del wc['out_secs']
print(wc)
\end{Verbatim}
\vspace{-.2in}

\begin{Verbatim}[fontsize=\scriptsize,samepage=true,frame=leftline,framesep=5mm,framerule=1mm]
      last     first    date  goals  assists  tackles  fouls  in_time  out_time
0   Morgan      Alex  28-Jun      0        0        2      1     0.00     90.00
1  Rapinoe     Megan  28-Jun      2        0        2      2     0.00     74.45
2    Press  Christen  28-Jun      0        0        1      0    74.45     90.00
3  Lavelle      Rose  28-Jun      0        1        3      0     0.00     90.00
4  Lavelle      Rose   7-Jul      1        0        4      1     0.00     90.00
5  Rapinoe     Megan   7-Jul      1        1        3      2     0.00     83.27
6    Lloyd     Carli   7-Jul      0        0        1      0    83.27     90.00
7     Dunn   Crystal  23-Jun      0        1        1      2    42.62     81.08
\end{Verbatim}
\end{samepage}

\index{transforming}

This is much less unwieldy than dealing with minutes and seconds separately.
All we need to do now is \textbf{transform} our data by computing a new
quantity entirely: the {total number of minutes played} for each player in each
game. Again, Pandas makes this easy:

\begin{Verbatim}[fontsize=\small,samepage=true,frame=single,framesep=3mm]
wc['mins_played'] = wc['out_time'] - wc['in_time']
print(wc)
\end{Verbatim}
\vspace{-.2in}

\begin{Verbatim}[fontsize=\scriptsize,samepage=true,frame=leftline,framesep=5mm,framerule=1mm]
      last     first    date  goals  assists  tackles  fouls  in_time  out_time  mins_played
0   Morgan      Alex  28-Jun      0        0        2      1     0.00     90.00        90.00
1  Rapinoe     Megan  28-Jun      2        0        2      2     0.00     74.45        74.45
2    Press  Christen  28-Jun      0        0        1      0    74.45     90.00        15.55
3  Lavelle      Rose  28-Jun      0        1        3      0     0.00     90.00        90.00
4  Lavelle      Rose   7-Jul      1        0        4      1     0.00     90.00        90.00
5  Rapinoe     Megan   7-Jul      1        1        3      2     0.00     83.27        83.27
6    Lloyd     Carli   7-Jul      0        0        1      0    83.27     90.00         6.73
7     Dunn   Crystal  23-Jun      0        1        1      2    42.62     81.08        38.46
\end{Verbatim}

\index{starter@\texttt{starter}}
\index{where@\texttt{where()} function (NumPy)}

Before removing the \texttt{in\_time} and \texttt{out\_time} columns (which we
could keep around, but I want this to fit on the page) let's do something extra
snazzy. We might also be interested in which players \textit{started} which
games (as opposed to being a mid-game substitute). Obviously, a starter is
someone who entered the game at time 0. To create a new column for this, let's
use the NumPy \texttt{where()} function, which I find immeasurably useful.

The \texttt{np.where()} function works as follows. You give it three arguments.
The first is a query condition, using the same query syntax we learned back in
section~\ref{seriesQueries}. The second and third arguments are the values you
want to use \textit{if the query evaluates to \texttt{True}, or \texttt{False},
respectively}, for a particular row. Check it out:

\begin{samepage}
\begin{Verbatim}[fontsize=\small,samepage=true,frame=single,framesep=3mm]
wc['starter'] = np.where(wc['in_time'] == 0, True, False)
del wc['in_time']
del wc['out_time']
print(wc)
\end{Verbatim}
\vspace{-.2in}

\begin{Verbatim}[fontsize=\scriptsize,samepage=true,frame=leftline,framesep=5mm,framerule=1mm]
      last     first    date  goals  assists  tackles  fouls  mins_played  starter
0   Morgan      Alex  28-Jun      0        0        2      1        90.00     True
1  Rapinoe     Megan  28-Jun      2        0        2      2        74.45     True
2    Press  Christen  28-Jun      0        0        1      0        15.55    False
3  Lavelle      Rose  28-Jun      0        1        3      0        90.00     True
4  Lavelle      Rose   7-Jul      1        0        4      1        90.00     True
5  Rapinoe     Megan   7-Jul      1        1        3      2        83.27     True
6    Lloyd     Carli   7-Jul      0        0        1      0         6.73    False
7     Dunn   Crystal  23-Jun      0        1        1      2        38.46    False
\end{Verbatim}
\end{samepage}

Pretty cool, huh? The original \texttt{DataFrame} had the information we
wanted, but not in the form we really needed it. What we wanted was not the
entry time and exit time of each player (both in minutes and seconds) but
rather the total time that player was on the pitch, and whether or not they
started the game.

Recoding and transforming turn out to be common tasks for a simple reason:
\textit{whoever collects a data set can rarely predict how an analyst will
eventually use it.} We're very grateful to the author of the \texttt{.csv}
file, since it contains the raw material we need to evaluate our team's
performances; but how were they to know that length-of-time-on-the-field and
who-started-which-game was going to be important to us? They couldn't. But
thanks to recoding and transformation skills, we can cope.

