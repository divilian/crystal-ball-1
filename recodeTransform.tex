
\chapter{Recoding and transforming}

\index{US Women's National Team}

It's often the case that although a \texttt{DataFrame} contains the information
you need for your analysis, it's not exactly in the form you need it. Consider
the following soccer data set called \texttt{worldcup2019.csv}:

\begin{Verbatim}[fontsize=\small,samepage=true,frame=lines,framesep=3mm]
last,first,date,in_time,out_time,goals,assists,tackles,fouls
Morgan,Alex,28-Jun-2019,0.0,90.0,0,0,2,1
Rapinoe,Megan,28-Jun-2019,0.0,74.0,2,0,2,2
Press,Christen,28-Jun-2019,74.0,90.0,0,0,1,0
Lavelle,Rose,28-Jun-2019,0.0,90.0,0,1,3,0
Lavelle,Rose,7-Jul-2019,0.0,90.0,1,0,4,1
Rapinoe,Megan,7-Jul-2019,0.0,83.0,1,1,3,2
Lloyd,Carli,7-Jul-2019,87.0,90.0,0,0,1,0
Dunn,Crystal,23-Jun-2019,42.0,81.0,0,1,1,2
\end{Verbatim}

\index{set\_index@\texttt{.set\_index()} method (Pandas)}

This particular \texttt{.csv} file doesn't really have a meaningful index
column. None of the columns are expected to be unique. So we'll leave off the
``\texttt{.set\_index()}'' method call when we read it in:

\begin{samepage}
\begin{Verbatim}[fontsize=\scriptsize,samepage=true,frame=single,framesep=3mm]
wc = pd.read_csv('worldcup2019.csv')
print(wc)
\end{Verbatim}
\vspace{-.2in}

\begin{Verbatim}[fontsize=\scriptsize,samepage=true,frame=leftline,framesep=5mm,framerule=1mm]
      last     first    date  in_mins  in_secs  out_mins  out_secs  goals  assists  tackles  fouls
0   Morgan      Alex  28-Jun        0        0        90         0      0        0        2      1
1  Rapinoe     Megan  28-Jun        0        0        74        27      2        0        2      2
2    Press  Christen  28-Jun       74       27        90         0      0        0        1      0
3  Lavelle      Rose  28-Jun        0        0        90         0      0        1        3      0
4  Lavelle      Rose   7-Jul        0        0        90         0      1        0        4      1
5  Rapinoe     Megan   7-Jul        0        0        83        16      1        1        3      2
6    Lloyd     Carli   7-Jul       83       16        90         0      0        0        1      0
7     Dunn   Crystal  23-Jun       42       37        81         5      0        1        1      2
\end{Verbatim}
\end{samepage}

(As you can see, Pandas put in a numeric index column for us.)

Each row of this \texttt{DataFrame} represents one player in one 2019 World Cup
game. Notice we have a couple of players with more than one row (Megan Rapinoe
and Rose Lavelle), and several rows for the same game (the first four rows are
all from the June 28th game, for instance).

Let's zero in on the columns with \texttt{mins} and \texttt{secs} in the names.
These columns show us the minute and second that the player went \texttt{in} to
the game, and the minute and second that they came \texttt{out}. For example,
Alex Morgan played the entire 90-minute match on June 28th. Rapinoe started
that game, but came out for a substitute at the 74:27 mark. Who replaced her?
Looks like Christen Press did, since she \textit{entered} the game at exactly
the same time. In most rows, the player either started the game, or ended the
game or both, but the last row (Crystal Dunn's June 23rd performance) has her
entering at 42:37 and exiting at 81:05.

Now the reason I bring this up is because one aspect of our analysis might be
computing statistics \textit{per minute} that each athlete played. If one
player scored 3 goals in 200 minutes, for example, and another scored 3 goals
in just 150 minutes, we could reasonably say that the second player was a more
prolific scorer in that World Cup.

\index{recoding}

This is hard to do with the data in the form that it stands. So we'll
\textbf{recode} a few of the columns. Let's collapse the minutes and seconds
for each of the two clock times into a single value, in minutes:

% TODO: round to two decimal places
\begin{Verbatim}[fontsize=\small,samepage=true,frame=single,framesep=3mm]
wc['in_time'] = wc['in_mins'] + (wc['in_secs'] / 60)
wc['out_time'] = wc['out_mins'] + (wc['out_secs'] / 60)
\end{Verbatim}

\index{vectorized@``vectorized'' operation}

We're taking advantage of vectorized operations here. For each row, we need to
divide the \texttt{in\_secs} value by 60 (to convert it to minutes) and add it
to the \texttt{in\_mins} value. Pandas makes this super easy here, since we can
just write out those operations once, and it will compute it for every single
row!

Let's delete the old, superfluous columns now and see what we've got:

\begin{samepage}
\begin{Verbatim}[fontsize=\small,samepage=true,frame=single,framesep=3mm]
del wc['in_mins']
del wc['in_secs']
del wc['out_mins']
del wc['out_secs']
print(wc)
\end{Verbatim}
\vspace{-.2in}

\begin{Verbatim}[fontsize=\scriptsize,samepage=true,frame=leftline,framesep=5mm,framerule=1mm]
      last     first    date  goals  assists  tackles  fouls  in_time  out_time
0   Morgan      Alex  28-Jun      0        0        2      1     0.00     90.00
1  Rapinoe     Megan  28-Jun      2        0        2      2     0.00     74.45
2    Press  Christen  28-Jun      0        0        1      0    74.45     90.00
3  Lavelle      Rose  28-Jun      0        1        3      0     0.00     90.00
4  Lavelle      Rose   7-Jul      1        0        4      1     0.00     90.00
5  Rapinoe     Megan   7-Jul      1        1        3      2     0.00     83.27
6    Lloyd     Carli   7-Jul      0        0        1      0    83.27     90.00
7     Dunn   Crystal  23-Jun      0        1        1      2    42.62     81.08
\end{Verbatim}
\end{samepage}

\index{transforming}

This is much less unwieldy than dealing with minutes and seconds separately.
All we need to do now is \textbf{transform} our data by computing a new
quantity entirely: the {total number of minutes played} for each player in each
game. Again, Pandas makes this easy:

\begin{Verbatim}[fontsize=\small,samepage=true,frame=single,framesep=3mm]
wc['mins_played'] = wc['out_time'] - wc['in_time']
print(wc)
\end{Verbatim}
\vspace{-.2in}

\begin{Verbatim}[fontsize=\scriptsize,samepage=true,frame=leftline,framesep=5mm,framerule=1mm]
      last     first    date  goals  assists  tackles  fouls  in_time  out_time  mins_played
0   Morgan      Alex  28-Jun      0        0        2      1     0.00     90.00        90.00
1  Rapinoe     Megan  28-Jun      2        0        2      2     0.00     74.45        74.45
2    Press  Christen  28-Jun      0        0        1      0    74.45     90.00        15.55
3  Lavelle      Rose  28-Jun      0        1        3      0     0.00     90.00        90.00
4  Lavelle      Rose   7-Jul      1        0        4      1     0.00     90.00        90.00
5  Rapinoe     Megan   7-Jul      1        1        3      2     0.00     83.27        83.27
6    Lloyd     Carli   7-Jul      0        0        1      0    83.27     90.00         6.73
7     Dunn   Crystal  23-Jun      0        1        1      2    42.62     81.08        38.46
\end{Verbatim}

\index{starter@\texttt{starter}}
\index{where@\texttt{where()} function (NumPy)}

% START HERE: instead of np.where, use a function with an if statement.

Before removing the \texttt{in\_time} and \texttt{out\_time} columns (which we
could keep around, but I want this to fit on the page) let's do something extra
snazzy. We might also be interested in which players \textit{started} which
games (as opposed to being a mid-game substitute). Obviously, a starter is
someone who entered the game at time 0. To create a new column for this, let's
use the NumPy \texttt{where()} function, which I find immeasurably useful.

The \texttt{np.where()} function works as follows. You give it three arguments.
The first is a query condition, using the same query syntax we learned back in
section~\ref{seriesQueries}. The second and third arguments are the values you
want to use \textit{if the query evaluates to \texttt{True}, or \texttt{False},
respectively}, for a particular row. Check it out:

\begin{samepage}
\begin{Verbatim}[fontsize=\small,samepage=true,frame=single,framesep=3mm]
wc['starter'] = np.where(wc['in_time'] == 0, True, False)
del wc['in_time']
del wc['out_time']
print(wc)
\end{Verbatim}
\vspace{-.2in}

\begin{Verbatim}[fontsize=\scriptsize,samepage=true,frame=leftline,framesep=5mm,framerule=1mm]
      last     first    date  goals  assists  tackles  fouls  mins_played  starter
0   Morgan      Alex  28-Jun      0        0        2      1        90.00     True
1  Rapinoe     Megan  28-Jun      2        0        2      2        74.45     True
2    Press  Christen  28-Jun      0        0        1      0        15.55    False
3  Lavelle      Rose  28-Jun      0        1        3      0        90.00     True
4  Lavelle      Rose   7-Jul      1        0        4      1        90.00     True
5  Rapinoe     Megan   7-Jul      1        1        3      2        83.27     True
6    Lloyd     Carli   7-Jul      0        0        1      0         6.73    False
7     Dunn   Crystal  23-Jun      0        1        1      2        38.46    False
\end{Verbatim}
\end{samepage}

Pretty cool, huh? The original \texttt{DataFrame} had the information we
wanted, but not in the form we really needed it. What we wanted was not the
entry time and exit time of each player (both in minutes and seconds) but
rather the total time that player was on the pitch, and whether or not they
started the game.

Recoding and transforming turn out to be common tasks for a simple reason:
\textit{whoever collects a data set can rarely predict how an analyst will
eventually use it.} We're very grateful to the author of the \texttt{.csv}
file, since it contains the raw material we need to evaluate our team's
performances; but how were they to know that length-of-time-on-the-field and
who-started-which-game was going to be important to us? They couldn't. But
thanks to recoding and transformation skills, we can cope.

