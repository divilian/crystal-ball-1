
% TODO:
%    .append() with ignore_index=True
%     OR maybe just .reset_index(drop=True)   (more general purpose)
%
% memory diagrams, including .copy()

\chapter{Three kinds of aggregate data}

Now it's time to consider loftier goals for our lowly atomic bits of data. Most
anything interesting in Data Science comes from arranging them together in
various ways to form more complex structures. This chapter is the subject of
these.

\section{Aggregate data types}

The number of ways in which pieces of data can be arranged is far greater than
the number of atomic types. These different ways all have names, some of them
nerdy and/or exotic like ``hash tables,'' ``binary search trees,'' or ``skip
lists.'' Nevertheless, there are again three basic ones which will form the
basis of our study: they're called \textbf{arrays}, \texttt{associative
arrays}, and \texttt{tables}. As before, we'll consider each one conceptually
first, and then look at how to use them in Python.

\subsection{Arrays}

Also sometimes called \textbf{\texttt{list}s}, \textbf{\texttt{vector}s}, or
\textbf{\texttt{sequence}s}.

\subsection{Associative arrays}

\subsection{Data frames}

\section{The three kinds in Python}

\subsection{Arrays: \texttt{numpy}'s \texttt{ndarray}}

\subsection{Associative arrays: Python's \texttt{dict}}

\subsection{Data frames: \texttt{pandas}'s \texttt{DataFrame}}


% Somewhere: .map() for recoding
