
% Other stuff I mentioned in class:
%
% For math, you think holistically. For programming, you think sequentially /
%   algorithmically.

\chapter{Three kinds of atomic data}
\label{ch:atomicData}

\section{Atomic data}

\index{atomic}
\index{indivisible}
When we say that some data is ``\textbf{atomic},'' we don't mean it's
radioactive; we mean it's \textit{indivisible}.

\index{Democritus}
\index{apple}
The ancients spoke of ``atoms'' as the smallest possible bits of matter. If you
divide up any physical object -- say, an apple -- into parts, you get its
components: a stalk, a stem, skin, seeds, and the sweet juicy stuff. Cut up any
of \textit{those} pieces with a knife and you get smaller pieces. If you
continue to split and split and split, philosophers like Democritus reasoned,
you'll eventually get to tiny indivisible bits that cannot be further
dissected. This is where the physical world bottoms out at the finest degree of
granularity.

Similarly, a piece of atomic data is typically treated as an entire unit, not
as something with internal structure that can be broken down. In the next
chapter we'll learn about various ways that these atoms of data can be strung
together and organized into larger wholes; for now, though, we're just looking
at the atoms themselves.

\section{Environments and variables}

\label{sec:envsAndVariables}
\index{environment}
\index{variable}
\index{variable!name}
\index{variable!value}
A data analysis program -- of which we will write many in this course -- makes
use of an \textbf{environment} as it runs. ``Environment'' just means ``all the
data that is currently in view, and which the program can
access.''\footnote{Confusingly, this use of the term ``environment'' is
different from the term ``programming environment'' I introduced on
p.\pageref{programmingEnvironment}.}  The environment consists of
\textbf{variables}, each of which (usually) has a \textbf{name} and a
\textbf{value}. For example, we might have a variable named \texttt{age} whose
value is 21, and a variable named \texttt{slogan} whose value is
\texttt{"Finger lickin' good"}.

\index{variable!name}
Each variable in the environment must have a \textit{distinct} name
(\textit{i.e.}, no two variables can share the same name). Also, importantly,
the reason these building blocks are called ``variables'' is that their value
can \textit{change} as the program executes. Although we may initially create
an \texttt{age} variable with the value \texttt{21}, later on in the program
the variable's value might change to \texttt{22}, or \texttt{50}, or
\texttt{0}. The variable's \textit{name} never changes, though.

\section{Atomic data types}

\index{variable!type}
There's one other thing that a variable has in addition to its name and value:
a \textbf{type}.\footnote{Strictly speaking, although in languages like Java
variables indeed have types, in Python the \textit{values} have types, not the
variables. This distinction will never be important for us though.}  In a
programming language like Python, every piece of data has a specific type,
which is necessary for determining how it behaves and what all you can do to
it. A question you should ask yourself a lot is: ``okay, I've got a variable in
my environment called \texttt{x}...now what is its type?'' You might have
guessed (correctly) that our \texttt{age} and \texttt{slogan} variables from
the previous section are of different types: one is a number, and the other is
a phrase.

In this course, we'll principally deal with three types of atomic data, all of
which will be familiar to you.


\subsection{Whole numbers}

\index{variable!whole number}
\index{whole number}
\index{likes@``likes''}
\index{votes}
One very common type of data is whole numbers, or integers. These are usually
positive, but can be negative, and have no decimal point. Things like a
person's birth year, a candidate's vote total, or a social media post's number
of ``likes'' are represented with this data type.


\subsection{Real (fractional) numbers}

\index{variable!real number}
\index{real number}
\index{fractional number}
\index{Facebook}
\index{movie rating}
\index{interest rate}
\index{temperature}
You may remember from high school math that the so-called ``real numbers''
include not only integers, but also numbers with digits after the decimal
point. This type can therefore be used to store interest rates, temperature
readings, and average movie ratings on a 1-to-5 scale.

Since all whole numbers are themselves real numbers, you might wonder why we
bother to define two different types for these. Why not just give both kinds of
variables the same real number type? Basically, the answer is that something
``feels wrong'' about that to the Data Science community. A Facebook user might
have 240 friends, or 241, but it would never make sense for her to have 240.3
friends. A consensus has thus arisen: variables that would only ever store
whole numbers really ought to be of a type that's devoted to only whole
numbers. You can violate this convention, but you'll be thought weird by your
fellow developers if you do so.


\subsection{Text}

\index{text}
\index{variable!text}
Lastly, some values obviously aren't numeric at all, like a customer's name, a
show title, or a tweet. So our third type of data is textual. Variables of this
type have a sequence of characters as values. These characters are most often
English letters, but can also include spaces, punctuation, and characters from
other alphabets.

\index{atomic}
\index{Avengers: Endgame@\textit{Avengers: Endgame}}
By the way, this third data type can tiptoe right up to the ``atomic'' line and
sometimes cross it. In other words, we will occasionally work with text values
\textit{non}-atomically, by splitting them up into their constituent words or
even letters. Most of the time, though, we'll treat a character sequence like
\texttt{"Avengers:\ Endgame"} as a single, indivisible chunk of data in the
same way we treat a number like \texttt{42}.

\subsection{But what about...?}

\index{song file}
\index{image file}
\index{video file}
What about other things a computer can store: images, song files, videos? It
turns out that through clever tricks, all these kinds of media and more can be
boiled down to a large number of integers, and stored in an aggregate data
structure like those discussed in the next chapter. At the atomic level, we'll
really only ever need to deal with the three types of this section.

\section{The three kinds in Python}

\index{language-general}
Now the three kinds of atomic data described above are
\textbf{language-general}: this means that they're conceptual, not tied to any
specific programming language or analysis tool. \textit{Any} technology used
for Data Science will have the ability to deal with those three basic types.
The specific ways they do so will differ somewhat from language to language.
Let's learn about how Python implements them.

\subsection{Whole numbers: \texttt{int}}

\index{int@\texttt{int}}
\index{integer}
One of the most basic Python data types is the ``\texttt{int},'' which stands
for ``integer.'' It's what we use to represent whole numbers.

\index{variable!value}
In Python, you create a variable by simply typing its name, an equals sign, and
then its initial value, like so:

\begin{Verbatim}[fontsize=\small,samepage=true,frame=single,framesep=3mm]
revolution = 1776
\end{Verbatim}

\index{line of code}
\index{code}
\index{executing@executing (code)}
\index{statement}
This is our first \textbf{line of code}\footnote{By the way, the word
\textbf{code} is grammatically a mass noun, not a count noun. Hence it is
proper to say ``I wrote some code last night,'' not ``I wrote some codes last
night.'' If you misuse this, it will brand you as a newbie right away.}. As
we'll see, lines of code are \textbf{executed} one by one -- there is a time
before, and a time after, each line is actually carried out. This will turn out
to be very important. (Oh, and a ``line of code'' is sometimes also called a
\textbf{statement}.)


\index{variable!name}
\index{underscore}
Python variable names can be as long as you like, provided they consist only of
upper and lower case letters, digits, and underscores. (You do have to be
consistent with your capitalization and your spelling: you can't call a
variable \texttt{Movie} in one line of code and \texttt{movie} in another.)
Underscores are often used as pseudo-spaces, but no other weird punctuation
marks are allowed in a variable's name.\footnote{Oh, and another rule: a
variable name can't \textit{start} with a digit. So \texttt{r2d2} is a legal
variable name, but not \texttt{007bond}.}

\index{movie rating}
\index{revolution@\texttt{revolution}}
And while we're on the subject, let me encourage you to \textit{name your
variables well}. This means that each variable name should reflect
\textit{exactly} what the value that it stores represents. Example: if a
variable is meant to store the rating (in ``stars'') that an IMDB user gave to
a movie, don't name it \texttt{movie}. Name it \texttt{rating}. (Or even
better, \texttt{movie\_rating}.) Trust me: when you're working on a complex
program, there's enough hard stuff to think about without confusing yourself
(and your colleagues) by close-but-not-exact variable names.\footnote{And I
fully own up to the fact that the \texttt{revolution} variable isn't named very
well. I chose it to make a different point shortly.}

\index{variable!type}
Now remember that a variable has three things -- a name, value, and type. The
first two explicitly appear in the line of code itself. As for the type, how
does Python know that \texttt{revolution} should be an ``\texttt{int}?''
Simple: it's \textit{a number with no decimal point.}

As a sanity check, we can ask Python to tell us the variable's type explicitly,
by writing this code:

\index{type@\texttt{type()}}
\label{typeFunction}
\begin{Verbatim}[fontsize=\small,samepage=true,frame=single,framesep=3mm]
type(revolution)
\end{Verbatim}

If this line of code is executed after the previous one is executed, Python
responds with:

\begin{Verbatim}[fontsize=\small,samepage=true,frame=leftline,framesep=5mm,framerule=1mm]
int
\end{Verbatim}

So there you go.

\index{code snippet}
\index{snippet}
Here's another ``\textbf{code snippet}'' (a term that just means ``some lines
of code I'm focusing on, which are generally only part of a larger program''):

\begin{Verbatim}[fontsize=\small,samepage=true,frame=single,framesep=3mm]
revolution = 1776
moon_landing = 1969
revolution = 1917
\end{Verbatim}

\index{revolution@\texttt{revolution}}
Now if this were a math class, that set of equations would be nonsensical. How
could the same variable (\texttt{revolution}) have two contradictory values?
But in a \textit{program}, this is perfectly legit: it just means that
immediately after the first line of code executes, \texttt{revolution} has the
value \texttt{1776}, and moments later, after the third line executes, its
value has changed to \texttt{1917}. Its value depends entirely on ``where the
program is'' during its execution.

\subsection{Real (fractional) numbers: \texttt{float}}

\index{float@\texttt{float}}
The only odd thing about the second data type in Python is its name. In some
other universe it might have been called a ``real'' or a ``decimal'' or a
``fractional'' variable, but for some bizarre historical reasons it is called a
\texttt{float}.\footnote{If you're curious, this is because in computer
programming parlance a ``floating-point number'' means a number where the
decimal point might be anywhere. With an integer like -52, the decimal point is
implicitly at the far right-hand side of the string of digits. But with numbers
like -5.2 or -.52 or -.000052 or even 520000, the decimal point has ``floated''
away from this fixed position.}

\index{decimal point}
All the same rules and regulations pertain to \texttt{float}s as they do to
\texttt{int}s; the only difference is you type a decimal point. So:

\begin{Verbatim}[fontsize=\small,samepage=true,frame=single,framesep=3mm]
GPA = 3.17
price_of_Christian_Louboutin_shoes = 895.95
interest_rate = 6.
\end{Verbatim}

\index{interest rate}
Note that the \texttt{interest\_rate} variable is indeed a \texttt{float} type
(even though it has no fractional part) because we typed a period:

\index{type@\texttt{type()}}
\begin{Verbatim}[fontsize=\small,samepage=true,frame=single,framesep=3mm]
type(interest_rate)
\end{Verbatim}
\begin{Verbatim}[fontsize=\small,samepage=true,frame=leftline,framesep=5mm,framerule=1mm]
float
\end{Verbatim}

\subsection{Text: \texttt{str}}

\index{string}
\index{str@\texttt{str}}
Speaking of weird names, a Python text variable is of type \texttt{str}, which
stands for ``\textbf{string}.'' You could think of it as a bunch of letters
``strung'' together like a beaded necklace.

\index{quotation marks}
\index{''@\texttt{\textquotesingle\textquotesingle} (ticks)}
\index{""@\texttt{\char`\"\char`\"} (quotes)}
Important: when specifying a \texttt{str} value, you must use \textbf{quotation
marks} (either single or double). For one thing, this is how Python tells that
you intend to create a \texttt{str} as opposed to some other type. Examples:

\index{lit}
\index{donut\_store@\texttt{donut\_store}}
\index{Paul's Bakery}
\begin{Verbatim}[fontsize=\small,samepage=true,frame=single,framesep=3mm]
slang = 'lit'
grade = "3rd"
donut_store = "Paul's Bakery"
url = 'http://umweagles.com'
\end{Verbatim}

\index{string!of digits}
\index{type@\texttt{type()}}
Notice, by the way, that a \textit{string of digits} is not the same as an
integer. To wit:

\begin{Verbatim}[fontsize=\small,samepage=true,frame=single,framesep=3mm]
schwarzenegger_weight = 249
action_movie = "300"

type(schwarzenegger_weight)
\end{Verbatim}
\begin{Verbatim}[fontsize=\small,samepage=true,frame=leftline,framesep=5mm,framerule=1mm]
int
\end{Verbatim}

\begin{Verbatim}[fontsize=\small,samepage=true,frame=single,framesep=3mm]
type(action_movie)
\end{Verbatim}
\begin{Verbatim}[fontsize=\small,samepage=true,frame=leftline,framesep=5mm,framerule=1mm]
str
\end{Verbatim}

See? The quotes make all the difference.

\subsubsection{The length of a string}

\index{string!length}
\index{len@\texttt{len()}}
We'll do many things with strings in this book. Probably the most basic is
simply to inquire as to a string's \textbf{length}, or the number of characters
it contains. To do this, we enclose the variable's name in parentheses after
the word \texttt{len}:

\begin{Verbatim}[fontsize=\small,samepage=true,frame=single,framesep=3mm]
len(slang)
\end{Verbatim}
\begin{Verbatim}[fontsize=\small,samepage=true,frame=leftline,framesep=5mm,framerule=1mm]
3
\end{Verbatim}

\begin{Verbatim}[fontsize=\small,samepage=true,frame=single,framesep=3mm]
len(donut_store)
\end{Verbatim}
\begin{Verbatim}[fontsize=\small,samepage=true,frame=leftline,framesep=5mm,framerule=1mm]
13
\end{Verbatim}

\label{function}
\index{lingo}
\index{function}
\index{argument}
\index{calling a function@``calling'' a function}
As we'll see, the \texttt{len()} operation (and many others like it) is an
example of a \textbf{function} in Python. In proper lingo, when we write a line
of code like \texttt{len(donut\_store)} we say we are ``\textbf{calling the
function},'' which simply means to invoke or trigger it.

\index{pass}
\index{passing an argument@``passing'' an argument}
\index{bananas (parentheses)}
\index{()@\texttt{()} (bananas)}
More lingo: for obscure reasons, the value inside the bananas
(\texttt{donut\_store}, in this case) is called an \textbf{argument} to the
function. And we say that we ``\textbf{pass}'' one or more arguments to a
function when we call it.

All these terms may seem pedantic, but they are precise and universally-used,
so be sure to learn them. The preceding line of code can be completely summed
up by saying:

\begin{quote}
``We are \textbf{calling} the \texttt{len()} \textbf{function},
and \textbf{passing} it the \texttt{donut\_store} \textbf{variable} as an
\textbf{argument}.''
\end{quote}

I recommend you say that sentence out loud at least four times in a row to get
used to its rhythm.

Note, by the way, that the \texttt{len()} function expects a \texttt{str}
argument. You can't call \texttt{len()} with an \texttt{int} or a
\texttt{float} variable as an argument:

\begin{Verbatim}[fontsize=\small,samepage=true,frame=single,framesep=3mm]
schwarzenegger_weight = 249

len(schwarzenegger_weight)
\end{Verbatim}

\begin{Verbatim}[fontsize=\small,samepage=true,frame=leftline,framesep=5mm,framerule=1mm]
TypeError: object of type 'int' has no len()
\end{Verbatim}

(You might think that the ``length'' of an \texttt{int} would be its number of
digits, but nope.)

\index{variable}
\index{variable!value}
One thing that students often get confused is the difference between a named
string \textit{variable} and that of an (unnamed) string \textit{value}.
Consider the difference in outputs of the following:

\begin{Verbatim}[fontsize=\small,samepage=true,frame=single,framesep=3mm]
slang = 'lit'
len(slang)
\end{Verbatim}
\begin{Verbatim}[fontsize=\small,samepage=true,frame=leftline,framesep=5mm,framerule=1mm]
3
\end{Verbatim}
\begin{Verbatim}[fontsize=\small,samepage=true,frame=single,framesep=3mm]
len('slang')
\end{Verbatim}
\begin{Verbatim}[fontsize=\small,samepage=true,frame=leftline,framesep=5mm,framerule=1mm]
5
\end{Verbatim}

In the first example, we asked ``how long is the value being held in the
\texttt{slang} variable?'' The answer was 3, since ``\texttt{lit}'' is three
characters long. In the second example, we asked ``how long is the word
\texttt{'slang'}?'' and the answer is 5. Remember: variable names never go in
quotes. If something is in quotes, it's being taken \textit{literally}.


\subsection{Combining and printing variables}

\index{printing a variable}
\index{print@\texttt{print()}}
There's a whole lot of stuff you can do with variables other than just creating
them. One thing you'll want to do frequently is \textbf{print} a variable,
which means to dump its value to the page so you can see it. This is easily
done by calling the \texttt{print()} function:

\begin{Verbatim}[fontsize=\small,samepage=true,frame=single,framesep=3mm]
print(donut_store)
print(price_of_Christian_Louboutin_shoes)
print("slang")
print(slang)
\end{Verbatim}

\begin{Verbatim}[fontsize=\small,samepage=true,frame=leftline,framesep=5mm,framerule=1mm]
Paul's Bakery
895.95
slang
lit
\end{Verbatim}

Again, don't miss the crucial difference between printing \texttt{"slang"} and
printing \texttt{slang}. The former is literal and the latter is not. In the
first of these, we're passing the \textit{word} ``\texttt{slang}'' as the
argument, not the variable \texttt{slang}.

\index{method}
Often we'll want to combine bits of information into a single print statement.
Typically one of the variables is a string that contains the overall message.
There are several ways to accomplish this, but the most flexible will turn out
to be the \texttt{.format()} \textbf{method}.

\index{calling a method@``calling'' a method (on a variable)}
\index{on@``on''}
I hate to hit you with so much new lingo. A \textbf{method} is very similar to
a function, but not exactly. The difference is in the syntax used to call it.
When you call a function (like \texttt{type()} or \texttt{len()}) you simply
type its name, followed by a pair of bananas inside of which you put the
arguments (separated by commas, if there's more than one). But when you ``call
a method,'' you put \textit{a variable} before a dot (``\texttt{.}'') and the
method name, then the bananas. This is referred to as ``calling the method
\textbf{on} the variable.''

It sounds more confusing than it is. Here's an example of \texttt{.format()} in
action:

\begin{Verbatim}[fontsize=\small,samepage=true,frame=single,framesep=3mm]
price_of_Christian_Louboutin_shoes = 895.95
message = "Honey, I spent ${} today!"
print(message.format(price_of_Christian_Louboutin_shoes))
\end{Verbatim}

\index{matching bananas}
\index{double bananas@``double bananas''}
Take note of how we write ``\texttt{message.format}'' instead of just
``\texttt{format}''. This is because \texttt{.format()} is a method, not a
function. We say that we are calling \texttt{.format()} ``on''
\texttt{message}, and passing \texttt{price\_of\_}\ \texttt{Christian\_Louboutin\_shoes}
as an argument.\footnote{Btw, in this book, whenever I refer to a method, I'll
be sure to put a dot before its name. For example, it's not the
``\texttt{format()}'' method, but the ``\texttt{.format()}'' method.} Also be
sure to notice the \textit{double} bananas ``\texttt{))}'' at the end of that
last line. We need both of them because in programming, every left-banana must
match a corresponding right-banana. Since we're calling two functions/methods
on one line (\texttt{print()} and \texttt{.format()}), we had two left-bananas
on that line. Each one needs a partner.

\index{\{\}@\texttt{\{\}} (curlies)}
As for the specifics of how \texttt{.format()} works, you'll see that the
string variable you call it on may include pairs of curlies (squiggly braces).
These are placeholders for where to stick the values of other variables in the
output. Those variables are then included as arguments to the
\texttt{.format()} method. The above code produces this output:

\begin{Verbatim}[fontsize=\small,samepage=true,frame=leftline,framesep=5mm,framerule=1mm]
Honey, I spent $895.95 today!
\end{Verbatim}

Often, instead of creating a new variable name to hold the pre-formatted
string, we'll just \texttt{print()} it literally, like this:

\begin{Verbatim}[fontsize=\footnotesize,samepage=true,frame=single,framesep=3mm]
print("Honey, I spent ${} today!".format(
    price_of_Christian_Louboutin_shoes))
\end{Verbatim}

We're still actually calling \texttt{.format()} on a variable here, it's just
that we haven't bothered to name the variable. Also, notice that our code was
too long to fit on one line nicely, so we broke it in two, and indented the
second line to make it clear that ``\texttt{price\_of\_}...'' wasn't starting
\index{bananas (parentheses)}
\index{()@\texttt{()} (bananas)}
its own new line. Crucially, all the bananas are still paired up, two-by-two,
even though the left bananas are on a different line than the corresponding
right bananas.

\bigskip
Finally, here's a longer example with more variables:

\begin{Verbatim}[fontsize=\footnotesize,samepage=true,frame=single,framesep=3mm]
name = "Pedro Pascal"
num_items = 3
cost = 91.73
print("Customer {} bought {} items worth ${}.".format(name,
    num_items, cost))
\end{Verbatim}

\begin{Verbatim}[fontsize=\small,samepage=true,frame=leftline,framesep=5mm,framerule=1mm]
Customer Pedro Pascal bought 3 items worth $91.73.
\end{Verbatim}

You can see how we can pass more than one argument to a function/method simply
by separating them with commas inside the bananas.
